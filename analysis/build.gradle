apply plugin: 'groovy'

buildscript {
    repositories {
        mavenLocal()
        mavenCentral()
        jcenter()
    }

    dependencies {
        classpath group:"de.dfki.mary", name:"marytts-analysis", version: "0.1"
    }
}



import marytts.analysis.distances.acoustic.*;
import marytts.analysis.distances.string.*;
import marytts.analysis.Statistics;
import marytts.analysis.alignment.IDAlignment;
import marytts.analysis.utils.LoadingHelpers;
import groovy.json.*

/***************************************************************************************************
 ***
 ***************************************************************************************************/

def slurper = new JsonSlurper()
def config_file =  new File(System.getProperty("configuration"))
def config = slurper.parseText( config_file.text )

def list_file = new File(DataFileFinder.getFilePath("list_test"))

def synth_dir = "../synthesis/build/output"
def nat_dir = "../training/build"
def nat_lab_dir = DataFileFinder.getFilePath(config.data.full_lab_dir)
def list = "list_test"

/*******************************************************************************************
 **
 *******************************************************************************************/
task computeRMSEF0() {
    def output_f = new File("$buildDir/rms_f0.csv")
    outputs.files output_f
    doLast {
        def loading = new LoadingHelpers();
        output_f.text = "#id\trms(cent)\n"

        list_file.eachLine { line ->
            //
            double[][] src = loading.loadFloatBinary("${nat_dir}/lf0/${line}.lf0", 1);
            double[][] tgt = loading.loadFloatBinary("${synth_dir}/imposed_dur/${line}.lf0", 1);

            def nb_frames = Math.min(src.length, tgt.length)
            for (int i=0; i<nb_frames; i++)
            {
                if (src[i][0] != -1.0e+10)
                {
                    src[i][0] = Math.exp(src[i][0])
                }
                else
                {
                    src[i][0] = 0;
                }

                if (tgt[i][0] != -1.0e+10)
                {
                    tgt[i][0] = Math.exp(tgt[i][0])
                }
                else
                {
                    tgt[i][0] = 0;
                }
            }

            // Generate path
            def alignment = new IDAlignment(nb_frames);
            def v = new CentRMS(src, tgt, 0.0);
            Double d = v.distancePerUtterance(alignment);
            output_f << "$line\t$d\n";
        }
    }
}

task computeVUVRate() {
    def output_f = new File("$buildDir/voice_error.csv")
    outputs.files output_f
    doLast {
        def loading = new LoadingHelpers();
        output_f.text = "#id\tvoice_error\n"

        list_file.eachLine { line ->
            //
            double[][] src = loading.loadFloatBinary("${nat_dir}/lf0/${line}.lf0", 1);
            double[][] tgt = loading.loadFloatBinary("${synth_dir}/imposed_dur/${line}.lf0", 1);

            def nb_frames = Math.min(src.length, tgt.length)
            for (int i=0; i<nb_frames; i++)
            {
                if (src[i][0] != -1.0e+10)
                {
                    src[i][0] = Math.exp(src[i][0])
                }
                else
                {
                    src[i][0] = 0;
                }

                if (tgt[i][0] != -1.0e+10)
                {
                    tgt[i][0] = Math.exp(tgt[i][0])
                }
                else
                {
                    tgt[i][0] = 0;
                }
            }

            // Generate path
            def alignment = new IDAlignment(nb_frames);
            def v = new VoicingError(src, tgt, 0.0);
            Double d = v.distancePerUtterance(alignment);
            output_f << "$line\t$d\n";
        }
    }
}

task computeRMSEEMA() {

    def output_f = new File("$buildDir/rms_ema.csv")
    outputs.files output_f
    doLast {
        def loading = new LoadingHelpers();
        output_f.text = "#id\trmse\n"

        list_file.eachLine { line ->
            //
            double[][] src = loading.loadFloatBinary("${nat_dir}/ema/${line}.ema", 21); // FIXME: hardcoded frame size
            double[][] tgt = loading.loadFloatBinary("${synth_dir}/imposed_dur/${line}.ema", 21); // FIXME: hardcoded frame size

            def nb_frames = Math.min(src.length, tgt.length)

            // Generate path
            def alignment = new IDAlignment(nb_frames);
            def v = new RMS(src, tgt, 21); // FIXME: hardcoded frame size
            Double d = v.distancePerUtterance(alignment);
            output_f << "$line\t$d\n";
        }
    }

}

task adaptDurToLab() {
    doLast {
        // FIXME: tmp for debug
        (new File("$buildDir/lab")).mkdirs()
        list_file.eachLine { line ->
            exec {
                commandLine "perl", "utils/duration2htk.pl", "${synth_dir}/normal/${line}.dur", "$buildDir/lab/${line}.lab"
            }
        }
    }
}

task computeRMSEDur() {
    dependsOn adaptDurToLab

    def output_f = new File("$buildDir/rms_dur.csv")
    outputs.files output_f

    doLast {

        output_f.text = "#id\trms (ms)\n"

        list_file.eachLine { line ->

            // Loading first label
           def ref_dur_list = []
           (new File("$nat_lab_dir/${line}.lab")).eachLine { label -> // FIXME: hardcoded reference name
               def elts = label.split()
               ref_dur_list << (elts[1].toInteger() - elts[0].toInteger())/ 10000
           }
           double[][] ref_dur = new double[ref_dur_list.size()][1];
           ref_dur_list.eachWithIndex {val, idx ->
               ref_dur[idx][0] = val
           }

            // Loading first label
           def synth_dur_list = []
           (new File("$buildDir/lab/${line}.lab")).eachLine { label -> // FIXME: hardcoded synth name
               def elts = label.split()
               synth_dur_list << (elts[1].toInteger() - elts[0].toInteger())/ 10000
           }

           double[][] synth_dur = new double[synth_dur_list.size()][1];
           synth_dur_list.eachWithIndex {val, idx ->
               synth_dur[idx][0] = val
           }

           if (synth_dur.length != ref_dur.length) {
               throw new Exception("what ?");
           }


            // Generate path
            def alignment = new IDAlignment(synth_dur.length);
            def v = new RMS(ref_dur, synth_dur, 1);
            Double d = v.distancePerUtterance(alignment);
            output_f << "$line\t$d\n";
        }
    }
}

task computeMCDIST() {

    def output_f = new File("$buildDir/mcdist.csv")
    outputs.files output_f
    doLast {
        def loading = new LoadingHelpers();
        output_f.text = "#id\tmcdist\n"

        list_file.eachLine { line ->
            //
            double[][] src = loading.loadFloatBinary("${nat_dir}/mgc/${line}.mgc", 50); // FIXME: hardcoded frame size
            double[][] tgt = loading.loadFloatBinary("${synth_dir}/imposed_dur/${line}.mgc", 50); // FIXME: hardcoded frame size

            def nb_frames = Math.min(src.length, tgt.length)

            // Generate path
            def alignment = new IDAlignment(nb_frames);
            def v = new CepstralDistorsion(src, tgt, 50); // FIXME: hardcoded frame size
            Double d = v.distancePerUtterance(alignment);
            output_f << "$line\t$d\n";
        }
    }
}

task generateReport() {

    def ema_activated = false
    def lf0_activated = false
    def mgc_activated = false
    def bap_activated = false

    config.models.cmp.streams.each { stream ->
        if (stream.kind == "lf0") {
            lf0_activated = true
            dependsOn computeRMSEF0, computeVUVRate
        }

        if (stream.kind == "mgc") {
            mgc_activated = true
            dependsOn computeMCDIST
        }

        /*
        if (stream.kind == "bap") {
            bap_activated = true
            dependsOn computeRMSEBAP
        }
        */

        if (stream.kind == "ema") {
            ema_activated = true
            dependsOn computeRMSEEMA
        }
    }

    dependsOn computeRMSEDur

    def input_rms_f0 = new File("$buildDir/rms_f0.csv")
    def input_vuvrate = new File("$buildDir/voice_error.csv")
    def input_mcdist = new File("$buildDir/mcdist.csv")
    def input_rms_dur = new File("$buildDir/rms_dur.csv")
    def input_rms_bap = new File("$buildDir/rms_bap.csv")
    def input_rms_ema = new File("$buildDir/rms_ema.csv")
    def output_f = new File("$buildDir/report.csv")
    outputs.files output_f

    doLast {
        output_f.text = "#id\tmean\tstd\tconfint\n"

        // RMS DUR part
        def values = []
        input_rms_dur.eachLine { line ->
            if (line.startsWith("#"))
                return; // Continue...

            def elts = line.split()
            values << Double.parseDouble(elts[1])
        }
        def dist = new Double[values.size()];
        values.toArray(dist);
        def s = new Statistics(dist);
        output_f << "rms dur\t" << s.mean() << "\t" << s.stddev() << "\t" << s.confint(0.05) << "\n"


        // RMS F0 part
        if (lf0_activated) {
            values = []
            input_rms_f0.eachLine { line ->
                if (line.startsWith("#"))
                    return; // Continue...

                    def elts = line.split()
                    values << Double.parseDouble(elts[1])
            }
            dist = new Double[values.size()];
            values.toArray(dist);
            s = new Statistics(dist);
            output_f << "rms f0\t" << s.mean() << "\t" << s.stddev() << "\t" << s.confint(0.05) << "\n"


            // Voice/Unvoice error rate part
            values = []
            input_vuvrate.eachLine { line ->
                if (line.startsWith("#"))
                    return; // Continue...

                    def elts = line.split()
                    values << Double.parseDouble(elts[1])
            }
            dist = new Double[values.size()];
            values.toArray(dist);
            s = new Statistics(dist);
            output_f << "vuvrate\t" << s.mean() << "\t" << s.stddev() << "\t" << s.confint(0.05) << "\n"
        }

        // Mel CepstralDistorsion part
        if (mgc_activated) {
            values = []
            input_mcdist.eachLine { line ->
                if (line.startsWith("#"))
                    return; // Continue...

                    def elts = line.split()
                    values << Double.parseDouble(elts[1])
            }
            dist = new Double[values.size()];
            values.toArray(dist);
            s = new Statistics(dist);
            output_f << "mcdist\t" << s.mean() << "\t" << s.stddev() << "\t" << s.confint(0.05) << "\n"
        }

        // RMS EMA part
        if (ema_activated) {
            values = []
            input_rms_ema.eachLine { line ->
                if (line.startsWith("#"))
                    return; // Continue...

                    def elts = line.split()
                    values << Double.parseDouble(elts[1])
            }
            dist = new Double[values.size()];
            values.toArray(dist);
            s = new Statistics(dist);
            output_f << "rms ema\t" << s.mean() << "\t" << s.stddev() << "\t" << s.confint(0.05) << "\n"
        }
    }
}

build.dependsOn generateReport
