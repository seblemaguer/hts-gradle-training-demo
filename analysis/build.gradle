buildscript {
    repositories {
        mavenLocal()
        mavenCentral()
        jcenter()
    }

    dependencies {
        classpath group:"de.dfki.mary", name:"marytts-analysis", version: "0.1"
    }
}

plugins {
  id 'distribution'
  id 'maven-publish'
}



ext {
    utilsDir = file("$rootDir/utils")
}


import marytts.analysis.distances.acoustic.*;
import marytts.analysis.distances.graphic.*;
import marytts.analysis.distances.string.*;
import marytts.analysis.Statistics;
import marytts.analysis.alignment.IDAlignment;
import marytts.analysis.utils.LoadingHelpers;
import groovy.json.*

/***************************************************************************************************
 ***
 ***************************************************************************************************/

// Specific to this architecture (FIXME: maybe generalize it ?)
def eval_name = System.getProperty("eval_name")
def synth_dir = "$buildDir/../../synthesis/build/output"
def nat_dir = "$buildDir/../../training/build"

def slurper = new JsonSlurper()
def config_file =  new File("$nat_dir/raw/config.json") // FIXME: nat_dir is not the most accurate name
def config = slurper.parseText( config_file.text )

def list_file = new File(DataFileFinder.getFilePath("list_test"))

def nat_lab_dir = DataFileFinder.getFilePath(config.data.mono_lab_dir)
def list = "list_test"
def channels = ["T3", "T2", "T1", "ref", "jaw", "upperlip", "lowerlip"]


/*******************************************************************************************
 ** Global distances
 *******************************************************************************************/
task adaptDurToLab() {
    doLast {
        // FIXME: tmp for debug
        (new File("$buildDir/lab")).mkdirs()
        list_file.eachLine { line ->
            exec {
                commandLine "perl", "utils/duration2htk.pl", "${synth_dir}/normal/${line}.dur", "$buildDir/lab/${line}.lab"
            }
        }
    }
}


/*******************************************************************************************
 ** Global distances
 *******************************************************************************************/
task computeRMSEF0() {
    (new File("$buildDir/$eval_name/global")).mkdirs()
    def output_f = new File("$buildDir/$eval_name/global/rms_f0.csv")
    outputs.files output_f
    doLast {
        def loading = new LoadingHelpers();
        output_f.text = "#id\trms(cent)\n"

        list_file.eachLine { line ->
            //
            double[][] src = loading.loadFloatBinary("${nat_dir}/lf0/${line}.lf0", 1);
            double[][] tgt = loading.loadFloatBinary("${synth_dir}/imposed_dur/${line}.lf0", 1);

            def nb_frames = Math.min(src.length, tgt.length)
            for (int i=0; i<nb_frames; i++)
            {
                if (src[i][0] != -1.0e+10)
                {
                    src[i][0] = Math.exp(src[i][0])
                }
                else
                {
                    src[i][0] = 0;
                }

                if (tgt[i][0] != -1.0e+10)
                {
                    tgt[i][0] = Math.exp(tgt[i][0])
                }
                else
                {
                    tgt[i][0] = 0;
                }
            }

            // Generate path
            def alignment = new IDAlignment(nb_frames);
            def v = new CentRMS(src, tgt, 0.0);
            Double d = v.distancePerUtterance(alignment);
            output_f << "$line\t$d\n";
        }
    }
}

task computeVUVRate() {
    (new File("$buildDir/$eval_name/global")).mkdirs()
    def output_f = new File("$buildDir/$eval_name/global/voice_error.csv")
    outputs.files output_f
    doLast {
        def loading = new LoadingHelpers();
        output_f.text = "#id\tvoice_error\n"

        list_file.eachLine { line ->
            //
            double[][] src = loading.loadFloatBinary("${nat_dir}/lf0/${line}.lf0", 1);
            double[][] tgt = loading.loadFloatBinary("${synth_dir}/imposed_dur/${line}.lf0", 1);

            def nb_frames = Math.min(src.length, tgt.length)
            for (int i=0; i<nb_frames; i++)
            {
                if (src[i][0] != -1.0e+10)
                {
                    src[i][0] = Math.exp(src[i][0])
                }
                else
                {
                    src[i][0] = 0;
                }

                if (tgt[i][0] != -1.0e+10)
                {
                    tgt[i][0] = Math.exp(tgt[i][0])
                }
                else
                {
                    tgt[i][0] = 0;
                }
            }

            // Generate path
            def alignment = new IDAlignment(nb_frames);
            def v = new VoicingError(src, tgt, 0.0);
            Double d = v.distancePerUtterance(alignment);
            output_f << "$line\t$d\n";
        }
    }
}

task computeRMSEEMA() {

    (new File("$buildDir/$eval_name/global")).mkdirs()
    def output_f = new File("$buildDir/$eval_name/global/rms_ema.csv")
    outputs.files output_f
    doLast {
        def loading = new LoadingHelpers();
        output_f.text = "#id\trmse\n"

        list_file.eachLine { line ->
            //
            double[][] src = loading.loadFloatBinary("${nat_dir}/ema/${line}.ema", 21); // FIXME: hardcoded frame size
            double[][] tgt = loading.loadFloatBinary("${synth_dir}/imposed_dur/${line}.ema", 21); // FIXME: hardcoded frame size

            def nb_frames = Math.min(src.length, tgt.length)

            // Generate path
            def alignment = new IDAlignment(nb_frames);
            def v = new RMS(src, tgt, 21); // FIXME: hardcoded frame size
            Double d = v.distancePerUtterance(alignment);
            output_f << "$line\t$d\n";
        }
    }
}

task computeEucDistEMA() {

    (new File("$buildDir/$eval_name/global")).mkdirs()
    def output_handles = []
    channels.each { c ->
        output_handles << new File("$buildDir/$eval_name/global/euc_dist_${c}.csv")
    }

    doLast {
        output_handles.each {f ->
            f.text = "# euc. dist. (cm)\n"
        }
        def loading = new LoadingHelpers();
        list_file.eachLine { line ->

            //
            double[][] src = loading.loadFloatBinary("${nat_dir}/ema/${line}.ema", 21); // FIXME: hardcoded frame size
            double[][] tgt = loading.loadFloatBinary("${synth_dir}/imposed_dur/${line}.ema", 21); // FIXME: hardcoded frame size


            // FIXME: hardcoded frame size
            int nb_frames = Math.min(src.length, tgt.length)
            for (int j=0; j<21; j+=3)
            {
                double[][] real_src = new double[nb_frames][3];
                double[][] real_tgt = new double[nb_frames][3];

                for (int i=0; i<nb_frames; i++)
                {
                    for (int k=0; k<3; k++)
                    {
                        real_src[i][k] = src[i][j+k]
                        real_tgt[i][k] = tgt[i][j+k]
                    }
                }


                def v = new EuclidianDistance(real_src, real_tgt, 3);
                for (int i=0; i<nb_frames; i++)
                {
                    output_handles[(j/3).intValue()] << v.distancePerFrame(i, i) << "\n"
                }
            }
        }
    }
}

task computeDistEMAPerPhoneme() {
    dependsOn adaptDurToLab

    (new File("$buildDir/$eval_name/global")).mkdirs()
    def output_f = new File("$buildDir/$eval_name/global/dist_euc_ema_per_phoneme.csv")
    outputs.files output_f
    doLast {
        def loading = new LoadingHelpers();
        def val = [:]
        list_file.eachLine { line ->

            //
            double[][] src = loading.loadFloatBinary("${nat_dir}/ema/${line}.ema", 21); // FIXME: hardcoded frame size
            double[][] tgt = loading.loadFloatBinary("${synth_dir}/imposed_dur/${line}.ema", 21); // FIXME: hardcoded frame size

            // Loading first label
            def ref_dur_list = []
            (new File("$nat_lab_dir/${line}.lab")).eachLine { label -> // FIXME: hardcoded reference name
                def elts = label.split()

                if (!(elts[2] in val)) {
                    val[elts[2]] = []
                    for (int i=0;i<7;i++) {
                        val[elts[2]][i] = []
                    }
                }

                def start = elts[0].toInteger() / (10000 * 5)
                def end = elts[1].toInteger() / (10000 * 5)

                // FIXME: hardcoded frame size
                int nb_frames = (end - start).intValue()
                for (int j=0; j<21; j+=3)
                {
                    double[][] real_src = new double[nb_frames][3];
                    double[][] real_tgt = new double[nb_frames][3];
                    for (int i=0; i<nb_frames; i++)
                    {
                        for (int k=0; k<3; k++)
                        {
                            real_src[i][k] = src[i][j+k]
                            real_tgt[i][k] = tgt[i][j+k]
                        }
                    }


                    def v = new EuclidianDistance(real_src, real_tgt, 3);
                    for (int i=0; i<nb_frames; i++)
                    {
                        val[elts[2]][(j/3).intValue()] << v.distancePerFrame(i, i)
                    }
                }
            }
        }


        output_f.text = "#label\tcoil\tnb_val\t\teuc_dist(mm)\tstdev\tconfint\n"
        val.each { k,v ->
            v.eachWithIndex {c,i ->
                def dist = new Double[c.size()];
                c.toArray(dist);
                def s = new Statistics(dist);
                output_f << "$k\t" << channels[i] <<"\t" << c.size() << "\t" << s.mean() << "\t" << s.stddev() << "\t" << s.confint(0.05) << "\n"
            }
        }
    }
}

task computeRMSEDur() {
    dependsOn adaptDurToLab

    (new File("$buildDir/$eval_name/global")).mkdirs()
    def output_f = new File("$buildDir/$eval_name/global/rms_dur.csv")
    outputs.files output_f

    doLast {

        output_f.text = "#id\trms (ms)\n"

        list_file.eachLine { line ->

            // Loading first label
            def ref_dur_list = []
            (new File("$nat_lab_dir/${line}.lab")).eachLine { label -> // FIXME: hardcoded reference name
                def elts = label.split()
                ref_dur_list << (elts[1].toInteger() - elts[0].toInteger())/ 10000
            }
            double[][] ref_dur = new double[ref_dur_list.size()][1];
            ref_dur_list.eachWithIndex {val, idx ->
                ref_dur[idx][0] = val
            }

            // Loading first label
            def synth_dur_list = []
            (new File("$buildDir/lab/${line}.lab")).eachLine { label -> // FIXME: hardcoded synth name
                def elts = label.split()
                synth_dur_list << (elts[1].toInteger() - elts[0].toInteger())/ 10000
            }

            double[][] synth_dur = new double[synth_dur_list.size()][1];
            synth_dur_list.eachWithIndex {val, idx ->
                synth_dur[idx][0] = val
            }

            if (synth_dur.length != ref_dur.length) {
                throw new Exception("what ?");
            }


            // Generate path
            def alignment = new IDAlignment(synth_dur.length);
            def v = new RMS(ref_dur, synth_dur, 1);
            Double d = v.distancePerUtterance(alignment);
            output_f << "$line\t$d\n";
        }
    }
}

task computeMCDIST() {

    (new File("$buildDir/$eval_name/global")).mkdirs()
    def output_f = new File("$buildDir/$eval_name/global/mcdist.csv")
    outputs.files output_f
    doLast {
        def loading = new LoadingHelpers();
        output_f.text = "#id\tmcdist\n"

        list_file.eachLine { line ->
            //
            double[][] src = loading.loadFloatBinary("${nat_dir}/mgc/${line}.mgc", 50); // FIXME: hardcoded frame size
            double[][] tgt = loading.loadFloatBinary("${synth_dir}/imposed_dur/${line}.mgc", 50); // FIXME: hardcoded frame size

            def nb_frames = Math.min(src.length, tgt.length)

            // Generate path
            def alignment = new IDAlignment(nb_frames);
            def v = new CepstralDistorsion(src, tgt, 50); // FIXME: hardcoded frame size
            Double d = v.distancePerUtterance(alignment);
            output_f << "$line\t$d\n";
        }
    }
}

task generateReport() {

    def ema_activated = false
    def lf0_activated = false
    def mgc_activated = false
    def bap_activated = false

    config.models.cmp.streams.each { stream ->
        if (stream.kind == "lf0") {
            lf0_activated = true
            dependsOn computeRMSEF0, computeVUVRate
        }

        if (stream.kind == "mgc") {
            mgc_activated = true
            dependsOn computeMCDIST
        }

        /*
          if (stream.kind == "bap") {
          bap_activated = true
          dependsOn computeRMSEBAP
          }
        */

        if (stream.kind == "ema") {
            ema_activated = true
            dependsOn computeRMSEEMA, computeEucDistEMA,computeDistEMAPerPhoneme
        }
    }

    dependsOn computeRMSEDur

    def input_rms_f0 = new File("$buildDir/$eval_name/global/rms_f0.csv")
    def input_vuvrate = new File("$buildDir/$eval_name/global/voice_error.csv")
    def input_mcdist = new File("$buildDir/$eval_name/global/mcdist.csv")
    def input_rms_dur = new File("$buildDir/$eval_name/global/rms_dur.csv")
    def input_rms_bap = new File("$buildDir/$eval_name/global/rms_bap.csv")
    def input_rms_ema = new File("$buildDir/$eval_name/global/rms_ema.csv")
    def ema_input_file = []
    channels.each { c -> ema_input_file << new File("$buildDir/$eval_name/global/euc_dist_${c}.csv")}


    def output_f = new File("$buildDir/report.csv")
    outputs.files output_f

    doLast {
        output_f.text = "#id\tmean\tstd\tconfint\n"

        // RMS DUR part
        def values = []
        input_rms_dur.eachLine { line ->
            if (line.startsWith("#"))
                return; // Continue...

                def elts = line.split()
                values << Double.parseDouble(elts[1])
        }
        def dist = new Double[values.size()];
        values.toArray(dist);
        def s = new Statistics(dist);
        output_f << "rms dur\t" << s.mean() << "\t" << s.stddev() << "\t" << s.confint(0.05) << "\n"


        // RMS F0 part
        if (lf0_activated) {
            values = []
            input_rms_f0.eachLine { line ->
                if (line.startsWith("#"))
                    return; // Continue...

                    def elts = line.split()
                    values << Double.parseDouble(elts[1])
            }
            dist = new Double[values.size()];
            values.toArray(dist);
            s = new Statistics(dist);
            output_f << "rms f0\t" << s.mean() << "\t" << s.stddev() << "\t" << s.confint(0.05) << "\n"


            // Voice/Unvoice error rate part
            values = []
            input_vuvrate.eachLine { line ->
                if (line.startsWith("#"))
                    return; // Continue...

                    def elts = line.split()
                    values << Double.parseDouble(elts[1])
            }
            dist = new Double[values.size()];
            values.toArray(dist);
            s = new Statistics(dist);
            output_f << "vuvrate\t" << s.mean() << "\t" << s.stddev() << "\t" << s.confint(0.05) << "\n"
        }

        // Mel CepstralDistorsion part
        if (mgc_activated) {
            values = []
            input_mcdist.eachLine { line ->
                if (line.startsWith("#"))
                    return; // Continue...

                    def elts = line.split()
                    values << Double.parseDouble(elts[1])
            }
            dist = new Double[values.size()];
            values.toArray(dist);
            s = new Statistics(dist);
            output_f << "mcdist\t" << s.mean() << "\t" << s.stddev() << "\t" << s.confint(0.05) << "\n"
        }

        // RMS EMA part
        if (ema_activated) {
            values = []
            input_rms_ema.eachLine { line ->
                if (line.startsWith("#"))
                    return; // Continue...

                    def elts = line.split()
                    values << Double.parseDouble(elts[1])
            }
            dist = new Double[values.size()];
            values.toArray(dist);
            s = new Statistics(dist);
            output_f << "rms ema\t" << s.mean() << "\t" << s.stddev() << "\t" << s.confint(0.05) << "\n"


            ema_input_file.eachWithIndex { c_file,i ->

                values = []
                c_file.eachLine { line ->
                    if (line.startsWith("#"))
                        return; // Continue...

                        values << Double.parseDouble(line)
                }
                dist = new Double[values.size()];
                values.toArray(dist);
                s = new Statistics(dist);
                output_f << "euc dist ${channels[i]} (cm)\t" << s.mean() << "\t" << s.stddev() << "\t" << s.confint(0.05) << "\n"
            }
        }
    }
}


/***************************************************************************************************
 *** Plotting
 ***************************************************************************************************/

/* Generate the test part */
(new File(DataFileFinder.getFilePath("list_test"))).each { basename ->
    project(":$basename") {
        buildDir = project.parent.buildDir


        task convertNaturalEMAToJson() {

            outputs.files "$buildDir/$eval_name/ema_analysis/json"

            doLast {
                (new File("$buildDir/$eval_name/ema_analysis/json")).mkdirs()

                project.exec {
                    commandLine "python3 ema2json.py ${nat_dir}/ema/${basename}.ema $buildDir/$eval_name/ema_analysis/json/${basename}.json".tokenize()
                    workingDir rootProject.ext.utilsDir
                }

            }
        }

        task gatherGenNatEMAInformations() {
            dependsOn convertNaturalEMAToJson

            def output_dir = "$buildDir/$eval_name/ema_analysis/csv"

            outputs.files output_dir

            doLast {

                (new File(output_dir)).mkdirs()
                def output_file = new File("$output_dir/${basename}.csv")
                output_file.text = "id_frame\ttimestamp\tcoil\ttype\taxis\tvalue\n"

                def orig_info = slurper.parseText( (new File("$buildDir/$eval_name/ema_analysis/json/${basename}.json")).text )
                def synth_info = slurper.parseText( (new File("${synth_dir}/imposed_dur/${basename}.json")).text )

                channels.each { c ->

                    orig_info.channels[c].position.eachWithIndex { pos, id ->

                        // Dump info + x
                        if ((id%3) == 0) {
                            def id_frame = (id / 3).intValue()
                            def timestamp = id_frame * config.signal.frameshift / 1000
                            output_file << "$id_frame\t$timestamp\t$c\tnatural\tx\t$pos\n"
                        }

                        // Dump y
                        if ((id%3) == 1) {
                            def id_frame = (id / 3).intValue()
                            def timestamp = id_frame * config.signal.frameshift / 1000
                            output_file << "$id_frame\t$timestamp\t$c\tnatural\ty\t$pos\n"
                        }

                        // Dump z + new basename
                        if ((id%3) == 2) {
                            def id_frame = (id / 3).intValue()
                            def timestamp = id_frame * config.signal.frameshift / 1000
                            output_file << "$id_frame\t$timestamp\t$c\tnatural\tz\t$pos\n"
                        }
                    }

                    synth_info.channels[c].position.eachWithIndex { pos, id ->

                        // Dump info + x
                        if ((id%3) == 0) {
                            def id_frame = (id / 3).intValue()
                            def timestamp = id_frame * config.signal.frameshift / 1000
                            output_file << "$id_frame\t$timestamp\t$c\tsynthesized\tx\t$pos\n"
                        }

                        // Dump y
                        if ((id%3) == 1) {
                            def id_frame = (id / 3).intValue()
                            def timestamp = id_frame * config.signal.frameshift / 1000
                            output_file << "$id_frame\t$timestamp\t$c\tsynthesized\ty\t$pos\n"
                        }

                        // Dump z + new basename
                        if ((id%3) == 2) {
                            def id_frame = (id / 3).intValue()
                            def timestamp = id_frame * config.signal.frameshift / 1000
                            output_file << "$id_frame\t$timestamp\t$c\tsynthesized\tz\t$pos\n"
                        }
                    }
                }
            }

        }


        task generateEMATrajectories() {
            dependsOn gatherGenNatEMAInformations

            def output_dirs = "$buildDir/$eval_name/ema_analysis/plots"
            channels.each { c ->
                (new File("$buildDir/$eval_name/ema_analysis/plots/$c")).mkdirs()
            }
            outputs.files "$buildDir/$eval_name/ema_analysis/plots"

            doLast {
                channels.each { c ->
                    project.exec{
                        commandLine "Rscript jsonPlotter.R $buildDir/$eval_name/ema_analysis/csv/${basename}.csv $c $buildDir/$eval_name/ema_analysis/plots/$c/${basename}.pdf".tokenize()
                        workingDir rootProject.ext.utilsDir
                    }
                }
            }
        }
    }
}

task generatePlots() {
    list_file.eachLine { basename ->

        config.models.cmp.streams.each { stream ->
            if (stream.kind == "ema") {
                dependsOn "${basename}:generateEMATrajectories"
            }
        }
    }
}

/***************************************************************************************************
 *** Publishing part
 ***************************************************************************************************/

group "$eval_name-analysis"
version '0.1-SNAPSHOT'

distributions {
  main {
    contents {
        from generateReport
        from generatePlots
        from "$buildDir/$eval_name"
        from "$buildDir/$eval_name"
    }
  }
}

publishing {
  publications {
    main(MavenPublication) {
      artifact distZip
    }
  }
  repositories {
    maven {
      url "http://localhost:8081/artifactory/data-snapshot-local/"
      credentials {
        username = findProperty('cloudarkUser')
        password = findProperty('cloudarkApiKey')
      }
    }
  }
}
